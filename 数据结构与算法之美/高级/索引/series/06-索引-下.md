# 数据库索引 - 索引 - 下


本节总结一些索引使用上的优化

## B-tree 与 B+ tree

索引组织表 与 堆表





UBER文章指出的基于B+tree即secondary index指向PK，仅仅是一种避免UPDATE数据需要索引的方法。
但是这种方法引入了一些问题如下 ：
1. 插入数据会变慢，因为数据存储是B+Tree结构的。
2. 如果插入的是随机的PK值，则会频繁的带来页分裂，会造成IO写放大。
3. 为了解决索引分裂的问题，导致了写堵塞读。 原因是引入了ChangeBuffer，当读的数据还在ChangeBuffer中时，需要先将其merge到b+tree，merge过程是堵塞读的。
4. 查询secondary时，要再走一遍primary index，带来了额外的离散扫描开销，如果secondary是范围扫描或者多点扫描，这个放大倍数是很可观的。 例如用户要从secondary index扫描10条记录，primary index的深度是4，那么除了secondary index的数据块扫描，还有额外多扫描40个primary的块。
5. 因为b+tree会将行存储在索引页中，所以一页能存下的记录数会大大减少，从而导致b+tree的层级比单纯的b-tree深一些。 特别是行宽较宽的表。
例如行宽为几百字节，16K的页可能就只能存储十几条记录，一千万记录的表，索引深度达到7级，加上metapage，命中一条记录需要扫描8个数据块。
而使用`PostgreSQL堆表+PK的方式`，索引页通常能存几百条记录（以16K为例，约存储800条记录），索引深度为3时能支撑5亿记录，所以命中一条记录实际上只需要扫描5个块(meta+2 branch+leaf+heap)。


推荐阅读

[为PostgreSQL讨说法 - 浅析《UBER ENGINEERING SWITCHED FROM POSTGRES TO MYSQL》](https://developer.aliyun.com/article/58421)

[Index-internals-PGCon2016.pdf](https://www.pgcon.org/2016/schedule/attachments/434_Index-internals-PGCon2016.pdf?spm=a2c6h.12873639.0.0.71d17af3OA90mG&file=434_Index-internals-PGCon2016.pdf)

[索引组织表](https://developer.aliyun.com/article/412188)

[堆表（heap table）](https://developer.aliyun.com/article/394393)

[Clustered Index Vs. Heap](http://kejser.org/clustered-indexes-vs-heaps/)
## 索引优化

### 

https://draveness.me/sql-index-intro/
看看一个BLOCK可以存储多少数据？

```sql
select reltuples/relpages from pg_class where relname='test';  
```

[高性能MySQL中的三星索引](https://www.cnblogs.com/MYSQLZOUQI/p/4573293.html)
## vacuum


