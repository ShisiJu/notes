## 数据库索引 - 索引 - 上

## 索引

这一章节, 我想讨论一些有趣的事情. 

### 大表如何加索引

在大表上创建一个索引将花费大量的时间; 默认情况下, 在创建的索引时, PostgreSQL 允许读数据 (select);
但是, 写数据的操作(insert, update , delete)会被阻塞, 知道索引创建完毕;

在生产环境下这是无法接受的;

那么, 在生产环境下, 怎么添加索引呢? 
数据库提供了一种可以并发创建索引的方法

```sql
create index concurrently index_name on table_name();
```

在索引创建完成之后, 数据库系统不得不和数据表(table) 保持同步;
这额外添加了数据的更新的操作; 
因此, 索引如果很少在查询中用到, 它应该被删除;



[PostgreSQL在线创建索引你不得不注意的"坑"](https://cloud.tencent.com/developer/article/1650565)

### 为什么创建索引时, 不能有数据更新

答: 假如在创建索引时 如果有一条`id = 100` 数据插入;
此时, 索引上是没有id = 100 的记录的;

那么, 当下一次通过索引查询这条记录时, 数据库会找不到 id = 100 的记录;

因此, 数据库在创建索引时, 会锁表; 不能进行数据的更新;

### 索引会影响order by的效率吗

答: 会有影响; 但是只有 B-tree 会;


索引除了可以帮助查询以外, 还能够帮助查询返回特定的顺序;
尤其适用于 `limit` 


For a query that requires scanning a large fraction of the table, an explicit sort is likely to be faster than
using an index because it requires less disk I/O due to following a sequential access pattern. Indexes
are more useful when only a few rows need be fetched. An important special case is ORDER BY in
combination with LIMIT n: an explicit sort will have to process all the data to identify the first n
rows, but if there is an index matching the ORDER BY, the first n rows can be retrieved directly,
without scanning the remainder at all.


可以让 `order by` 免去排序的步骤;

但是, 在PostgreSQL 中, 只有B-tree 才有这中效果;

这是因为, B-tree 的数据结构; 
在B-tree中, 叶子节点本身就是有序的;


```sql
explain (analyse,COSTS, VERBOSE,BUFFERS )
select *
from product 
order by id desc 
limit 10
```

`Index Scan Backward using product_pkey on public.product`

目前 only B-tree indexes can be declared unique
There's no need to manually create indexes on unique columns; doing so would just duplicate
the automatically-created index.



### pg 有聚簇索引么

答: pg 没有聚簇索引(clustered index);

PostgreSQL中的索引都是 二级索引 (secondary index), 这意味着每种索引都独立存储于表的主要数据区域(heap)之外;
这意味着一个普通的索引扫描, 每一行数据都需要从索引和 heap 中获取;

To solve this performance problem, PostgreSQL supports index-only scans, which can answer queries
from an index alone without any heap access. The basic idea is to return values directly out of each
index entry instead of consulting the associated heap entry. There are two fundamental restrictions on
when this method can be used:


从 heap中读取数据, 会造成许多的随机访问(random access), 使得效率降低;
为了解决这种性能问题, pg 支持了 `仅索引扫描 (index-only scans)`.
它可以直接返回查询语句需要的数据, 而不去heap中读取数据;


### 什么是回表


## 什么是 covering index


https://www.postgresql.org/docs/11/indexes-index-only-scans.html

推荐阅读

https://www.cnblogs.com/myseries/p/11265849.html





这一块 可以看看极客时间上的文章

[04 | 深入浅出索引（上）](https://time.geekbang.org/column/article/69236)

mysql 聚簇索引
主键B+树 叶子节点存储row 
非叶子节点存储 指针

主键索引的叶子节点存的是整行数据。
在 InnoDB 里，主键索引也被称为聚簇索引（ clustered index）。非主键索引的叶子节点内容是主键的值。
在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。


推荐阅读: 

[Database · 理论基础 · 高性能B-tree索引](http://mysql.taobao.org/monthly/2020/05/02/)

[mysql b+树能存多少条数据？b+树每层有多少分支？](https://blog.csdn.net/csdnlijingran/article/details/102309593)



## 

https://wiki.postgresql.org/wiki/Bitmap_Indexes



