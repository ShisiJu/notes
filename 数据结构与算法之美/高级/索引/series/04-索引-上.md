## 数据库索引 - 索引 - 上

## 索引

这一章节, 我想讨论一些有趣的事情. 

### 大表如何加索引

在大表上创建一个索引将花费大量的时间; 默认情况下, 在创建的索引时, PostgreSQL 允许读数据 (select);
但是, 写数据的操作(insert, update , delete)会被阻塞, 知道索引创建完毕;

在生产环境下这是无法接受的;

那么, 在生产环境下, 怎么添加索引呢? 
数据库提供了一种可以并发创建索引的方法

```sql
create index concurrently index_name on table_name();
```

在索引创建完成之后, 数据库系统不得不和数据表(table) 保持同步;
这额外添加了数据的更新的操作; 
因此, 索引如果很少在查询中用到, 它应该被删除;

[PostgreSQL在线创建索引你不得不注意的"坑"](https://cloud.tencent.com/developer/article/1650565)

### 为什么创建索引时, 不能有数据更新

答: 假如在创建索引时 如果有一条`id = 100` 数据插入;
此时, 索引上是没有id = 100 的记录的;

那么, 当下一次通过索引查询这条记录时, 数据库会找不到 id = 100 的记录;

因此, 数据库在创建索引时, 会锁表; 不能进行数据的更新;

### 索引会提高order by的速度吗

答: 会有影响; 但是只有 B-tree 会;


索引除了可以帮助查询以外, 还能够帮助查询返回特定的顺序;
尤其适用于 `limit` 

对于一个需要扫描大量数据的查询, 一个显式的(explicit)排序可能比使用索引更快，
因为它遵循顺序访问模式，所以需要较少的磁盘I/O。

在查询的数据量小的时候, 索引可能会更有用;
举一个例子:

```sql
select * FROM employees 
order by name
limit 10
```

在上面的sql中, 我们使用 `order by` 和 `limit`

如果, 我们没有在 name 上加入索引;
那么, 数据库会把所有的数据都拿出来, 根据name进行排序. 然后, 在排好顺序的数据中取前10条;

我们如果在 name上加入了索引, 
数据库可以直接在已经排好顺序的索引上, 读取前10条; 
从而省去了排序的时间;

但是, 在PostgreSQL 中, 只有B-tree 才有这中效果;

这是因为, B-tree 的数据结构; 
在B-tree中, 叶子节点本身就是有序的;

### pg 有聚簇索引么

答: pg 没有聚簇索引(clustered index);

不同于mysql, pg是堆表; 
PostgreSQL中的索引都是 二级索引 (secondary index), 这意味着每种索引都独立存储于表的主要数据区域(heap)之外;
这意味着一个普通的索引扫描, 每一行数据都需要从索引和 heap 中获取;

从 heap中读取数据, 会造成许多的随机访问(random access), 使得效率降低;
为了解决这种性能问题, pg 支持了 `仅索引扫描 (index-only scans)`.
它可以直接返回查询语句需要的数据, 而不去heap中读取数据;

### 什么是回表

答: 回表是在查询过程中, 需要去表中取数据, 从而触发了随机IO. 导致性能下降的一种情况;
通常情况下, 我们要避免回表;

二级索引回到主键索引查询数据，这个过程称作回表过程，而且这个回表过程是可以被优化的，这个优化就是利用覆盖索引。

[浅谈PostgreSQL的索引](https://www.cnblogs.com/lottu/p/7526700.html)

https://dba.stackexchange.com/questions/108987/what-do-the-shared-buffers-metrics-for-various-types-of-index-scans-represent


我们看下面的sql
我们加入只有在id上加入了索引;



```sql
explain (analyze,buffers) 
select * FROM employees 
where id = 100 and name = 'steven'
```

这没有体现回表啊

```sql
vacuum analyze tab1; 
```


虽然Index Only Scan 可以从索引直接输出结果。但是因为MVCC 机制的实现，需要对扫描的元组进行可见性判断，即检查visibility MAP 文件。当新建表之后，如果没有进行过vacuum和autovacuum操作，这时还没有VM文件，而索引并没有保存记录的版本信息，
索引Index Only Scan 还是需要扫描数据块（Heap Fetches 代表需要扫描的数据块个数）来获取版本信息，这时可能会比Index Scan 慢。

[pg中的执行计划与统计信息](https://blog.csdn.net/Hehuyi_In/article/details/101782808)

Buffers: shared hit=2 read=2


### 为什么hit的数量是 4 

`1 meta page + 1 root + 1 branch + 1 leaf`

[深入浅出PostgreSQL B-Tree索引结构](https://github.com/digoal/blog/blob/master/201605/20160528_01.md)


### in 和 区间


```sql
explain (analyze,buffers) 
select *
from product 
where id in (1,2,3,4,5)
```

Buffers: shared hit=17

```sql
explain (analyze,buffers) 
select *
from product 
where id > 0 and id < 6
```

Buffers: shared hit=5

## 什么是 covering index


https://www.postgresql.org/docs/11/indexes-index-only-scans.html

推荐阅读

https://www.cnblogs.com/myseries/p/11265849.html


这一块 可以看看极客时间上的文章

[04 | 深入浅出索引（上）](https://time.geekbang.org/column/article/69236)

mysql 聚簇索引
主键B+树 叶子节点存储row 
非叶子节点存储 指针

主键索引的叶子节点存的是整行数据。
在 InnoDB 里，主键索引也被称为聚簇索引（ clustered index）。非主键索引的叶子节点内容是主键的值。
在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。


推荐阅读: 

[Database · 理论基础 · 高性能B-tree索引](http://mysql.taobao.org/monthly/2020/05/02/)

[mysql b+树能存多少条数据？b+树每层有多少分支？](https://blog.csdn.net/csdnlijingran/article/details/102309593)



## 

https://wiki.postgresql.org/wiki/Bitmap_Indexes



