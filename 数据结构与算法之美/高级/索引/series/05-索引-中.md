# 数据库索引 - 索引 - 中

本节, 将深入地了解一下索引;


### 为什么选择B-tree作为索引

https://www.cnblogs.com/aspirant/p/9214485.html

尝试用学过的数据结构解决这个问题

散列表。散列表的查询性能很好，时间复杂度是 O(1)。但是，散列表不能支持按照区间快速查找数据。所以，散列表不能满足我们的需求。我们再来看平衡二叉查找树。尽管平衡二叉查找树查询的性能也很高，时间复杂度是 O(logn)。而且，对树进行中序遍历，我们还可以得到一个从小到大有序的数据序列，但这仍然不足以支持按照区间快速查找数据。我们再来看跳表。跳表是在链表之上加上多层索引构成的。它支持快速地插入、查找、删除数据，对应的时间复杂度是 O(logn)。并且，跳表也支持按照区间快速地查找数据。我们只需要定位到区间起点值对应在链表中的结点，然后从这个结点开始，顺序遍历链表，直到区间终点对应的结点为止，这期间遍历得到的数据就是满足区间值的数据。



常用数据库支持情况：

Oracle支持堆表，也支持索引组织表

PostgreSQL只支持堆表，不支持索引组织表

Innodb只支持索引组织表

[](https://www.sqlpassion.at/archive/2015/10/19/heap-tables-in-sql-server/)


### 为什么只有叶子节点


因为B+树只有叶子结点才存储表的记录信息，其他非叶子结点只存储数据(索引)，
所以高度为1和2的数据为1170个，叶子结点为16(一行1k，页的数据为16k)，
即高度为3的B+树可以存储的数据是1170*1170*16=2千万


B+树首先是有序结构，为了不至于树的高度太高，影响查找效率，在叶子节点上存储的不是单个数据，而是一页数据

B+ 树为什么只有叶子节点存数据?
有一道MySQL的面试题，为什么MySQL的索引要使用B+树而不是其它树形结构?比如B树？
现在这个问题的复杂版本可以参考本文；
他的简单版本回答是：
因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；


使用场景


[为什么生产环境中B+树的高度总是3-4层？](https://zhuanlan.zhihu.com/p/86137284)

https://stackoverflow.com/questions/256511/skip-list-vs-binary-search-tree?rq=1



## pg中的B-tree底层逻辑是怎样的


推荐阅读

[深入浅出PostgreSQL B-Tree索引结构](https://github.com/digoal/blog/blob/master/201605/20160528_01.md?spm=a2c6h.12873639.0.0.45131bff1F4qRA&file=20160528_01.md)

[github-pg-nbtree](https://github.com/postgres/postgres/tree/master/src/backend/access/nbtree)


### 为什么不选择跳表作为索引


作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。

如果你了解红黑树、AVL 树这样平衡二叉树，你就知道它们是通过左右旋的方式保持左右子树的大小平衡（如果不了解也没关系，我们后面会讲），而跳表是通过随机函数来维护前面提到的“平衡性”。



### B-tree 

对于相同个数的数据构建 m 叉树索引，m 叉树中的 m 越大，那树的高度就越小，那 m 叉树中的 m 是不是越大越好呢？到底多大才最合适呢？

不管是内存中的数据，还是磁盘中的数据，操作系统都是按页（一页大小通常是 4KB，这个值可以通过 getconfig PAGE_SIZE 命令查看）来读取的，一次会读一页的数据。如果要读取的数据量超过一页的大小，就会触发多次 IO 操作。所以，我们在选择 m 大小的时候，要尽量让每个节点的大小等于一个页的大小。读取一个节点，只需要一次磁盘 IO 操作。


### redis zset 为什么用 跳表 而不用 B+树?


1000w 数据

如果`每2个结点`提取一个结点到上一级，做索引, 就是 log2(1000w) 是 24 层;  
如果`每3个结点`提取一个结点到上一级，做索引, 就是 log3(1000w) 是 15 层;




因为B+树的原理是 叶子节点存储数据，非叶子节点存储索引，
B+树的每个节点可以存储多个关键字，它将节点大小设置为磁盘页的大小，
充分利用了磁盘预读的功能。每次读取磁盘页时就会读取一整个节点,

每个叶子节点还有指向前后节点的指针，为的是最大限度的降低磁盘的IO;

因为数据在内存中读取耗费的时间是从磁盘的IO读取的百万分之一

而Redis是 内存中读取数据，不涉及IO，因此使用了跳表； 

"在磁盘上数据是分磁道、分簇存储的，而数据往往并不是连续排列在同一磁道上，所以磁头在读取数据时往往需要在磁道之间反复移动，因此这里就有一个寻道耗时！另外，盘面旋转将请求数据所在扇区移至读写头下方也是需要时间，这里还存在一个旋转耗时！"

那么，在这一时间段（即"I/O等待"）内，线程是在“阻塞”着等待磁盘，
此时操作系统可以将那个空闲的CPU核心用于服务其他线程。

因此在I/O操作的情况下，使用多线程，效率会更高！


redis

There are a few reasons:

1) They are not very memory intensive. It's up to you basically. Changing parameters about the probability of a node to have a given number of levels will make then less memory intensive than btrees.

2) A sorted set is often target of many ZRANGE or ZREVRANGE operations, that is, traversing the skip list as a linked list. With this operation the cache locality of skip lists is at least as good as with other kind of balanced trees.

3) They are simpler to implement, debug, and so forth. For instance thanks to the skip list simplicity I received a patch (already in Redis master) with augmented skip lists implementing ZRANK in O(log(N)). It required little changes to the code.



推荐阅读: 

[聊聊Mysql索引和redis跳表](https://zhuanlan.zhihu.com/p/61900308)

[redis为何单线程 效率还这么高 为何使用跳表不使用B+树做索引(阿里)](https://my.oschina.net/u/4335884/blog/3367826)

## 倒排索引



