散列表用的是数组支持按照下标随机访问数据的特性，
所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。


- 散列函数计算得到的散列值是一个非负整数；
- 如果 key1 = key2，那 hash(key1) == hash(key2)；
- 如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。

第三点

## 散列冲突

线性探测法解

链表法

100_000 * 1 k

假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？

- 把数据放到 hashmap  key 是url value是点击次数
- key的数量不多 可以桶排序 大的话, 快速排序


有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？

- 第一个存 hashset
- 遍历第二个 有的话就是重复的


## 思考题

使用hashmap 和 list 实现缓存淘汰算法--LRU算法

https://zhuanlan.zhihu.com/p/34989978

https://github.com/rsms/js-lru


## bitmap

https://juejin.im/post/6844903769201704973


## 查询效率

散列表的查询效率并不能笼统地说成是 O(1)。
它跟散列函数、装载因子、散列冲突等都有关系。
如果散列函数设计得不好，或者装载因子过高，都可能导致散列冲突发生的概率升高，查询效率下降。



## 散列函数

散列函数生成的值要尽可能随机并且均匀分布

开放寻址法

链表法中的链表改造为其他高效的动态数据结构，比如跳表、红黑树。

比如Redis中的hash,set,hset,都是散列表实现，他们的动态扩容策略是同时维护两个散列表，然后一点点搬移数据


## js中

https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness#%E9%9B%B6%E5%80%BC%E7%9B%B8%E7%AD%89



## 均摊扩容

均摊的方法，将一次性扩容的代价，均摊到多次插入操作中，就避免了一次性扩容耗时过多的情况。这种实现方式，任何情况下，插入一个数据的时间复杂度都是 O(1)。


## hash算法

将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值.

1. 单向
2. 快速
3. hash分布冲突少
4. bit 

### hash算法的应用

安全加密、
唯一标识、
数据校验、
散列函数、
负载均衡、
数据分片、
分布式存储